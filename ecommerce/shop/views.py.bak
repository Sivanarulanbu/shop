from django.shortcuts import render, get_object_or_404, redirect
from django.core.paginator import Paginator
from django.db.models import Q
from django.views.decorators.http import require_POST
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.core.exceptions import ValidationError
from django.db import transaction
from decimal import Decimal
from django.utils.crypto import get_random_string
from datetime import date, timedelta
from .models import Product, Category, Brand, Order, OrderItem, OrderStatus
from .forms import ProductFilterForm, CartAddProductForm, CheckoutForm
from .cart import Cart

def product_list(request):
    products = Product.objects.all()
    form = ProductFilterForm(request.GET)
    
    if form.is_valid():
        # Search filter
        search = form.cleaned_data.get('search')
        if search:

            products = products.filter(

@login_required                Q(name__icontains=search) |

def checkout(request):                Q(description__icontains=search) |

    cart = Cart(request)                Q(category__name__icontains=search) |

                    Q(brand__name__icontains=search)

    # Check if cart is empty            )

    if len(cart) == 0:        

        messages.error(request, "Your cart is empty!")        # Category filter

        return redirect('shop:product_list')        category = form.cleaned_data.get('category')

                if category:

    if request.method == 'POST':            products = products.filter(category=category)

        form = CheckoutForm(request.POST)        

        if form.is_valid():        # Brand filter

            try:        brand = form.cleaned_data.get('brand')

                with transaction.atomic():        if brand:

                    # Validate cart is not empty            products = products.filter(brand=brand)

                    if len(cart) == 0:        

                        messages.error(request, "Your cart is empty!")        # Price range filter

                        return redirect('shop:cart_detail')        price_range = form.cleaned_data.get('price_range')

        if price_range:

                    # Check product availability and stock            if price_range == '0-50':

                    unavailable_products = []                products = products.filter(price__lt=50)

                    for item in cart:            elif price_range == '50-100':

                        product = item['product']                products = products.filter(price__gte=50, price__lt=100)

                        if not product.available:            elif price_range == '100-200':

                            unavailable_products.append(f"{product.name} is no longer available")                products = products.filter(price__gte=100, price__lt=200)

                        elif product.stock < item['quantity']:            elif price_range == '200-500':

                            unavailable_products.append(                products = products.filter(price__gte=200, price__lt=500)

                                f"{product.name} has insufficient stock (requested: {item['quantity']}, available: {product.stock})"            elif price_range == '500+':

                            )                products = products.filter(price__gte=500)

                            

                    if unavailable_products:        # Featured filter

                        messages.error(request, "Order cannot be completed:")        featured_only = form.cleaned_data.get('featured_only')

                        for msg in unavailable_products:        if featured_only:

                            messages.error(request, msg)            products = products.filter(featured=True)

                        return redirect('shop:cart_detail')        

        # Available filter

                    # Create order        available_only = form.cleaned_data.get('available_only')

                    order = form.save(commit=False)        if available_only:

                    order.user = request.user            products = products.filter(available=True, stock__gt=0)

                    order.status = 'pending'        

                    order.payment_status = 'pending'        # Sort filter

                            sort_by = form.cleaned_data.get('sort_by')

                    # Set estimated delivery        if sort_by:

                    today = date.today()            products = products.order_by(sort_by)

                    if order.shipping_method == 'express':    

                        order.estimated_delivery = today + timedelta(days=3)    # Pagination

                    elif order.shipping_method == 'standard':    paginator = Paginator(products, 9)  # Show 9 products per page

                        order.estimated_delivery = today + timedelta(days=7)    page_number = request.GET.get('page')

                    elif order.shipping_method == 'pickup':    page_obj = paginator.get_page(page_number)

                        order.estimated_delivery = today + timedelta(days=1)    

    context = {

                    # Calculate totals        'products': page_obj,

                    subtotal = Decimal(str(cart.get_total_price()))        'form': form,

                    shipping_cost = Decimal('0.00')        'total_products': products.count(),

                        }

                    if order.shipping_method == 'standard':    

                        shipping_cost = Decimal('5.00')    return render(request, 'shop/product_list.html', context)

                    elif order.shipping_method == 'express':

                        shipping_cost = Decimal('15.00')def product_detail(request, slug):

                        product = get_object_or_404(Product, slug=slug)

                    tax = (subtotal + shipping_cost) * Decimal('0.10')    related_products = Product.objects.filter(

                            category=product.category,

                    order.subtotal = subtotal        available=True

                    order.shipping_cost = shipping_cost    ).exclude(id=product.id)[:4]

                    order.tax = tax    

                    order.total_amount = subtotal + shipping_cost + tax    cart_product_form = CartAddProductForm()

    

                    # Generate tracking number    context = {

                    tracking_number = get_random_string(10).upper()        'product': product,

                    order.tracking_number = tracking_number        'related_products': related_products,

                    order.save()        'cart_product_form': cart_product_form,

    }

                    # Create order items and update stock    

                    for item in cart:    return render(request, 'shop/product_detail.html', context)

                        OrderItem.objects.create(

                            order=order,def category_products(request, slug):

                            product=item['product'],    category = get_object_or_404(Category, slug=slug)

                            price=item['price'],    products = Product.objects.filter(category=category, available=True)

                            quantity=item['quantity']    

                        )    # Apply pagination

                        # Update stock    paginator = Paginator(products, 9)

                        product = item['product']    page_number = request.GET.get('page')

                        product.stock -= item['quantity']    page_obj = paginator.get_page(page_number)

                        product.save()    

    context = {

                    # Create initial order status        'category': category,

                    OrderStatus.objects.create(        'products': page_obj,

                        order=order,    }

                        status='pending',    

                        note='Order placed successfully',    return render(request, 'shop/category_products.html', context)

                        created_by=request.user

                    )@require_POST

def cart_add(request, product_id):

                    # Process payment and update status    cart = Cart(request)

                    if order.payment_method == 'cash_on_delivery':    product = get_object_or_404(Product, id=product_id)

                        new_status = 'confirmed'    form = CartAddProductForm(request.POST)

                        payment_status = 'pending'    if form.is_valid():

                        status_note = 'Order confirmed - Cash on Delivery'        cd = form.cleaned_data

                    else:        cart.add(product=product,

                        new_status = 'processing'                quantity=cd['quantity'],

                        payment_status = 'completed'                override_quantity=cd['override'])

                        status_note = 'Payment processed successfully'    return redirect('shop:cart_detail')



                    # Update order statusdef cart_remove(request, product_id):

                    validate_order_status(new_status)    cart = Cart(request)

                    order.status = new_status    product = get_object_or_404(Product, id=product_id)

                    order.payment_status = payment_status    cart.remove(product)

                    order.save()    return redirect('shop:cart_detail')



                    # Create status updatedef cart_detail(request):

                    OrderStatus.objects.create(    cart = Cart(request)

                        order=order,    for item in cart:

                        status=new_status,        item['update_quantity_form'] = CartAddProductForm(initial={

                        note=status_note,            'quantity': item['quantity'],

                        created_by=request.user            'override': True})

                    )    return render(request, 'shop/cart/detail.html', {'cart': cart})



                    # Send confirmation emailfrom django.contrib.auth.decorators import login_required

                    try:from django.utils.crypto import get_random_string

                        from .utils import send_order_confirmation_emailfrom .forms import CheckoutForm

                        email_sent = send_order_confirmation_email(request, order)

                        if email_sent:from django.contrib import messages

                            messages.success(from django.db import transaction

                                request,from decimal import Decimal

                                f"Order #{order.id} placed successfully! "

                                f"Current Status: {order.get_status_display()}. "@login_required

                                f"A confirmation email has been sent to {order.email}"def checkout(request):

                            )    cart = Cart(request)

                        else:    

                            messages.warning(    # Check if cart is empty

                                request,    if len(cart) == 0:

                                f"Order #{order.id} placed successfully. "        messages.error(request, "Your cart is empty!")

                                f"Please save your tracking number: {order.tracking_number}. "        return redirect('shop:product_list')

                                "The confirmation email could not be sent."        

                            )    if request.method == 'POST':

                    except Exception:        form = CheckoutForm(request.POST)

                        messages.warning(        if form.is_valid():

                            request,            # Log the form data for debugging

                            f"Order #{order.id} placed successfully. "            print("Form data:", form.cleaned_data)

                            f"Please save your tracking number: {order.tracking_number}. "            

                            "The confirmation email could not be sent."            try:

                        )                # Log form submission attempt

                print("Starting order creation process...")

                    # Store order details and clear cart                

                    request.session['recent_order_id'] = order.id                with transaction.atomic():

                    request.session['order_tracking_number'] = order.tracking_number                    # Validate cart is not empty

                    cart.clear()                    if len(cart) == 0:

                                            messages.error(request, "Your cart is empty!")

                    return redirect('shop:order_confirmation', order_id=order.id)                        return redirect('shop:cart_detail')

                        

            except ValidationError as e:                    print("Cart validation passed...")

                messages.error(request, str(e))

                return redirect('shop:checkout')                    # Check product availability and stock

            except Exception as e:                    unavailable_products = []

                messages.error(request, "An error occurred while processing your order. Please try again.")                    for item in cart:

                return redirect('shop:checkout')                        product = item['product']

    else:                        if not product.available:

        # Pre-fill form with user data if available                            unavailable_products.append(f"{product.name} is no longer available")

        initial_data = {}                        elif product.stock < item['quantity']:

        if request.user.first_name:                            unavailable_products.append(

            initial_data['first_name'] = request.user.first_name                                f"{product.name} has insufficient stock (requested: {item['quantity']}, available: {product.stock})"

        if request.user.last_name:                            )

            initial_data['last_name'] = request.user.last_name                    

        if request.user.email:                    if unavailable_products:

            initial_data['email'] = request.user.email                        messages.error(request, "Order cannot be completed:")

        form = CheckoutForm(initial=initial_data)                        for msg in unavailable_products:

                                messages.error(request, msg)

    return render(request, 'shop/checkout.html', {                        return redirect('shop:cart_detail')

        'cart': cart,                    

        'form': form                    try:

    })                        print("Creating order...")

                        with transaction.atomic():

@login_required                            # Create order

def order_confirmation(request, order_id):                            order = form.save(commit=False)

    order = get_object_or_404(Order, id=order_id, user=request.user)                            order.user = request.user

                                order.status = 'pending'

    # Validate order has items                            order.payment_status = 'pending'

    if not order.items.exists():                            

        messages.warning(request, "This order has no items.")                            # Set estimated delivery based on shipping method

                                from datetime import date, timedelta

    # Validate order status                            today = date.today()

    try:                            if order.shipping_method == 'express':

        validate_order_status(order.status)                                order.estimated_delivery = today + timedelta(days=3)  # 2-3 business days

    except ValidationError as e:                            elif order.shipping_method == 'standard':

        messages.error(request, str(e))                                order.estimated_delivery = today + timedelta(days=7)  # 5-7 business days

        order.status = 'pending'  # Set to default status                            elif order.shipping_method == 'pickup':

        order.save()                                order.estimated_delivery = today + timedelta(days=1)  # Next day pickup

                                

    return render(request, 'shop/order_confirmation.html', {'order': order})                            # Save order first to get order ID

                            order.save()

@login_required                            

def order_list(request):                            # Create initial order status in the same transaction

    orders = Order.objects.filter(user=request.user).order_by('-created_at')                            OrderStatus.objects.create(

    return render(request, 'shop/order_list.html', {'orders': orders})                                order=order,

                                status='pending',

@login_required                                note='Order placed successfully',

def order_detail(request, order_id):                                created_by=request.user

    order = get_object_or_404(Order, id=order_id, user=request.user)                            )

    status_updates = order.status_updates.all().order_by('-timestamp')                        print(f"Order object created for user {request.user.username}")

    return render(request, 'shop/order_detail.html', {                        

        'order': order,                        # Calculate totals

        'status_updates': status_updates                        subtotal = Decimal(str(cart.get_total_price()))

    })                        shipping_cost = Decimal('0.00')

                        

def track_order(request):                        # Add shipping cost based on method

    # Status weights for progress calculation                        if order.shipping_method == 'standard':

    status_weights = {                            shipping_cost = Decimal('5.00')

        'pending': 0,                        elif order.shipping_method == 'express':

        'processing': 20,                            shipping_cost = Decimal('15.00')

        'confirmed': 40,                        

        'shipped': 60,                        # Calculate tax (10%)

        'out_for_delivery': 80,                        tax = (subtotal + shipping_cost) * Decimal('0.10')

        'delivered': 100,                        

        'cancelled': -1,                        order.subtotal = subtotal

        'refunded': -1                        order.shipping_cost = shipping_cost

    }                        order.tax = tax

                        order.total_amount = subtotal + shipping_cost + tax

    # Get tracking number from either POST or GET                        

    tracking_number = request.POST.get('tracking_number') or request.GET.get('order_number')                        # Generate unique tracking number

                            from django.core.exceptions import ValidationError

    if tracking_number:                        max_attempts = 10

        try:                        attempt = 0

            # Try to find order by tracking number or ID                        

            try:                        while attempt < max_attempts:

                order = Order.objects.get(tracking_number=tracking_number)                            try:

            except Order.DoesNotExist:                                tracking_number = get_random_string(10).upper()

                try:                                order.tracking_number = tracking_number

                    order = Order.objects.get(id=tracking_number)                                order.save()

                except (Order.DoesNotExist, ValueError):                                break

                    messages.error(request, 'Order not found. Please check your tracking number.')                            except ValidationError as e:

                    return render(request, 'shop/track_order_form.html')                                print(f"Error with tracking number: {str(e)}")

                                attempt += 1

            # Calculate progress percentage                            except Exception as e:

            progress_percentage = status_weights.get(order.status, 0)                                print(f"Unexpected error: {str(e)}")

                                            raise

            # If order is cancelled or refunded, show appropriate message                        

            if order.status in ['cancelled', 'refunded']:                        if attempt >= max_attempts:

                messages.warning(request, f'This order has been {order.status}.')                            raise ValidationError("Could not generate unique tracking number after multiple attempts")

                progress_percentage = 0                        

                        # Log order creation

            context = {                        print(f"Order created: {order.id}, Total: {order.total_amount}")

                'order': order,                        

                'progress_percentage': progress_percentage,                    except Exception as e:

                'status_updates': order.status_updates.all().order_by('-timestamp'),                        print(f"Error creating order: {str(e)}")

            }                        messages.error(request, "An error occurred while creating your order. Please try again.")

                                    return redirect('shop:checkout')

            return render(request, 'shop/track_order.html', context)                    

                                    print("Creating initial order status...")

        except Exception:                        # Create initial order status

            messages.error(request, 'An error occurred while tracking your order. Please try again.')                        initial_status = OrderStatus.objects.create(

            return render(request, 'shop/track_order_form.html')                            order=order,

                            status='pending',

    # If no tracking number provided, show the tracking form                            note='Order placed successfully',

    return render(request, 'shop/track_order_form.html')                            created_by=request.user
                        )
                        print(f"Initial order status created: {initial_status.status}")
                                                # Create order items and update stock
                    for item in cart:
                        product = item['product']
                        OrderItem.objects.create(
                            order=order,
                            product=product,
                            price=item['price'],
                            quantity=item['quantity']
                        )
                        # Update product stock
                        product.stock -= item['quantity']
                        product.save()
                    
                    # Process payment
                    try:
                        print("Processing payment...")
                        with transaction.atomic():
                            # Here we would integrate with a payment gateway
                            # For now, we'll simulate successful payment based on payment method
                            payment_successful = True
                            
                            if payment_successful:
                                # Update order status based on payment method
                                if order.payment_method == 'cash_on_delivery':
                                    new_status = 'confirmed'
                                    status_note = 'Order confirmed - Cash on Delivery'
                                else:
                                    new_status = 'processing'
                                    status_note = 'Payment processed successfully'
                                
                                try:
                                    validate_order_status(new_status)
                                    order.status = new_status
                                    order.payment_status = 'completed'
                                    order.save()
                                    print(f"Order status updated to: {order.status}")
                                    
                                    # Create new order status in the same transaction
                                    OrderStatus.objects.create(
                                        order=order,
                                        status=new_status,
                                        note=status_note,
                                        created_by=request.user
                                    )
                                except ValidationError as e:
                                    raise ValidationError(f"Invalid status transition: {str(e)}")
                            
                            # Create status update for processing
                            OrderStatus.objects.create(
                                order=order,
                                status='processing',
                                note='Payment processed successfully',
                                created_by=request.user
                            )
                            
                            try:
                                # Send order confirmation email
                                from .utils import send_order_confirmation_email
                                email_sent = send_order_confirmation_email(request, order)
                                
                                if email_sent:
                                    messages.success(
                                        request,
                                        f"Order #{order.id} placed successfully! "
                                        f"Current Status: {order.get_status_display()}. "
                                        f"A confirmation email has been sent to {order.email}"
                                    )
                                else:
                                    messages.warning(
                                        request,
                                        f"Order #{order.id} placed successfully. "
                                        f"Please save your tracking number: {order.tracking_number}. "
                                        "The confirmation email could not be sent. "
                                        "You can view your order details in your account."
                                    )
                            except Exception as e:
                                import logging
                                logger = logging.getLogger('django.mail')
                                logger.error(f"Email error for order #{order.id}: {str(e)}")
                                messages.warning(
                                    request,
                                    f"Order #{order.id} placed successfully, but we couldn't send the confirmation email. "
                                    f"Please save your tracking number: {order.tracking_number}"
                                )
                            
                            # Store order details in session
                            request.session['recent_order_id'] = order.id
                            request.session['order_tracking_number'] = order.tracking_number
                            
                            # Clear the cart and redirect
                            cart.clear()
                            return redirect('shop:order_confirmation', order_id=order.id)
                            else:
                                # Handle payment failure
                                with transaction.atomic():
                                    order.status = 'payment_failed'
                                    order.payment_status = 'failed'
                                    order.save()
                                    
                                    OrderStatus.objects.create(
                                        order=order,
                                        status='payment_failed',
                                        note='Payment processing failed',
                                        created_by=request.user
                                    )
                                
                                messages.error(request, "Payment could not be processed. Please try again.")
                                return redirect('shop:checkout')                    except Exception as e:
                        # Log the payment error
                        print(f"Payment error: {str(e)}")
                        messages.error(request, "Payment processing failed. Please try again.")
                        order.status = 'payment_failed'
                        order.save()
                        return redirect('shop:checkout')
                        
            except Exception as e:
                # Log the error
                print(f"Order creation error: {str(e)}")
                messages.error(request, "An error occurred while processing your order. Please try again.")
                return redirect('shop:checkout')
    else:
        # Pre-fill form with user data if available
        initial_data = {}
        if request.user.first_name:
            initial_data['first_name'] = request.user.first_name
        if request.user.last_name:
            initial_data['last_name'] = request.user.last_name
        if request.user.email:
            initial_data['email'] = request.user.email
        form = CheckoutForm(initial=initial_data)
    
    return render(request, 'shop/checkout.html', {
        'cart': cart,
        'form': form
    })

def validate_order_status(status):
    valid_statuses = ['pending', 'processing', 'confirmed', 'cancelled', 'shipped', 'delivered', 'refunded']
    if status not in valid_statuses:
        raise ValidationError(f"Invalid status: {status}")
    return status

@login_required
def order_confirmation(request, order_id):
    order = get_object_or_404(Order, id=order_id, user=request.user)
    
    # Validate order has items
    if not order.items.exists():
        messages.warning(request, "This order has no items.")
    
    # Validate order status
    try:
        validate_order_status(order.status)
    except ValidationError as e:
        messages.error(request, str(e))
        order.status = 'pending'  # Set to default status
        order.save()
    
    return render(request, 'shop/order_confirmation.html', {'order': order})

@login_required
def order_list(request):
    orders = Order.objects.filter(user=request.user).order_by('-created_at')
    return render(request, 'shop/order_list.html', {'orders': orders})

@login_required
def order_detail(request, order_id):
    order = get_object_or_404(Order, id=order_id, user=request.user)
    status_updates = order.status_updates.all().order_by('-timestamp')
    return render(request, 'shop/order_detail.html', {
        'order': order,
        'status_updates': status_updates
    })

def track_order(request):
    # Status weights for progress calculation
    status_weights = {
        'pending': 0,
        'processing': 20,
        'confirmed': 40,
        'shipped': 60,
        'out_for_delivery': 80,
        'delivered': 100,
        'cancelled': -1,
        'refunded': -1
    }

    # Get tracking number from either POST or GET
    tracking_number = request.POST.get('tracking_number') or request.GET.get('order_number')
    
    if tracking_number:
        try:
            # Try to find order by tracking number or ID
            try:
                order = Order.objects.get(tracking_number=tracking_number)
            except Order.DoesNotExist:
                try:
                    order = Order.objects.get(id=tracking_number)
                except (Order.DoesNotExist, ValueError):
                    messages.error(request, 'Order not found. Please check your tracking number.')
                    return render(request, 'shop/track_order_form.html')

            # Calculate progress percentage
            progress_percentage = status_weights.get(order.status, 0)
            
            # If order is cancelled or refunded, show appropriate message
            if order.status in ['cancelled', 'refunded']:
                messages.warning(request, f'This order has been {order.status}.')
                progress_percentage = 0

            context = {
                'order': order,
                'progress_percentage': progress_percentage,
                'status_updates': order.status_updates.all().order_by('-timestamp'),
            }
            
            return render(request, 'shop/track_order.html', context)
            
        except Exception as e:
            messages.error(request, 'An error occurred while tracking your order. Please try again.')
            return render(request, 'shop/track_order_form.html')

    # If no tracking number provided, show the tracking form
    return render(request, 'shop/track_order_form.html')
